"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./src/utils/autoLayout.ts":
/*!*********************************!*\
  !*** ./src/utils/autoLayout.ts ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getLayoutedElements: function() { return /* binding */ getLayoutedElements; }\n/* harmony export */ });\nconst nodeWidth = 260;\nconst nodeHeight = 120;\nconst nodeSpacingX = 80;\nconst nodeSpacingY = 80;\nfunction getRootNodeId(nodes, edges) {\n    // root הוא node שאין אליו אף edge\n    const allNodeIds = new Set(nodes.map((n)=>n.id));\n    const targetIds = new Set(edges.map((e)=>e.target));\n    for (const id of allNodeIds){\n        if (!targetIds.has(id)) return id;\n    }\n    return nodes.length > 0 ? nodes[0].id : null;\n}\nfunction getLayoutedElements(nodes, edges) {\n    let direction = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"TB\";\n    // בניית עץ היררכי: לכל node נשמור children\n    const nodeMap = Object.fromEntries(nodes.map((n)=>[\n            n.id,\n            n\n        ]));\n    const childrenMap = {};\n    nodes.forEach((n)=>{\n        childrenMap[n.id] = [];\n    });\n    edges.forEach((e)=>{\n        if (childrenMap[e.source]) childrenMap[e.source].push(e.target);\n    });\n    // חישוב level (עומק) לכל node\n    const levels = {};\n    const rootId = getRootNodeId(nodes, edges);\n    if (!rootId) return {\n        nodes,\n        edges\n    };\n    function assignLevels(nodeId, level) {\n        if (levels[nodeId] !== undefined && levels[nodeId] <= level) return;\n        levels[nodeId] = level;\n        for (const childId of childrenMap[nodeId]){\n            assignLevels(childId, level + 1);\n        }\n    }\n    assignLevels(rootId, 0);\n    // קיבוץ nodes לפי level\n    const levelsArr = [];\n    Object.entries(levels).forEach((param)=>{\n        let [id, lvl] = param;\n        if (!levelsArr[lvl]) levelsArr[lvl] = [];\n        levelsArr[lvl].push(id);\n    });\n    // חישוב X/Y לכל node: כל רמה בשורה, כל siblings בריווח שווה\n    const positions = {};\n    for(let lvl = 0; lvl < levelsArr.length; lvl++){\n        const ids = levelsArr[lvl];\n        const totalWidth = (ids.length - 1) * (nodeWidth + nodeSpacingX);\n        for(let i = 0; i < ids.length; i++){\n            const x = -totalWidth / 2 + i * (nodeWidth + nodeSpacingX);\n            const y = lvl * (nodeHeight + nodeSpacingY);\n            positions[ids[i]] = {\n                x,\n                y\n            };\n        }\n    }\n    // עדכון nodes עם מיקום\n    const layoutedNodes = nodes.map((node)=>{\n        return {\n            ...node,\n            position: {\n                x: positions[node.id].x,\n                y: positions[node.id].y\n            },\n            targetPosition: direction === \"LR\" ? \"left\" : \"top\",\n            sourcePosition: direction === \"LR\" ? \"right\" : \"bottom\",\n            data: {\n                ...node.data\n            }\n        };\n    });\n    return {\n        nodes: layoutedNodes,\n        edges\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDLEdBQUc7Z0JBQUVDO2dCQUFHQztZQUFFO1FBQzdCO0lBQ0Y7SUFFQSx1QkFBdUI7SUFDdkIsTUFBTUMsZ0JBQWdCckMsTUFBTUksR0FBRyxDQUFDLENBQUNrQztRQUMvQixPQUFPO1lBQ0wsR0FBR0EsSUFBSTtZQUNQQyxVQUFVO2dCQUNSSixHQUFHSixTQUFTLENBQUNPLEtBQUtoQyxFQUFFLENBQUMsQ0FBQzZCLENBQUM7Z0JBQ3ZCQyxHQUFHTCxTQUFTLENBQUNPLEtBQUtoQyxFQUFFLENBQUMsQ0FBQzhCLENBQUM7WUFDekI7WUFDQUksZ0JBQWdCM0IsY0FBYyxPQUFPLFNBQVM7WUFDOUM0QixnQkFBZ0I1QixjQUFjLE9BQU8sVUFBVTtZQUMvQzZCLE1BQU07Z0JBQ0osR0FBR0osS0FBS0ksSUFBSTtZQUNkO1FBQ0Y7SUFDRjtJQUVBLE9BQU87UUFBRTFDLE9BQU9xQztRQUFlcEM7SUFBTTtBQUN2QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvdXRpbHMvYXV0b0xheW91dC50cz8wOGEzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE5vZGUsIEVkZ2UgfSBmcm9tICdyZWFjdGZsb3cnO1xuXG5jb25zdCBub2RlV2lkdGggPSAyNjA7XG5jb25zdCBub2RlSGVpZ2h0ID0gMTIwO1xuY29uc3Qgbm9kZVNwYWNpbmdYID0gODA7XG5jb25zdCBub2RlU3BhY2luZ1kgPSA4MDtcblxuZnVuY3Rpb24gZ2V0Um9vdE5vZGVJZChub2RlczogTm9kZVtdLCBlZGdlczogRWRnZVtdKTogc3RyaW5nIHwgbnVsbCB7XG4gIC8vIHJvb3Qg15TXldeQIG5vZGUg16nXkNeZ158g15DXnNeZ15Ug15DXoyBlZGdlXG4gIGNvbnN0IGFsbE5vZGVJZHMgPSBuZXcgU2V0KG5vZGVzLm1hcChuID0+IG4uaWQpKTtcbiAgY29uc3QgdGFyZ2V0SWRzID0gbmV3IFNldChlZGdlcy5tYXAoZSA9PiBlLnRhcmdldCkpO1xuICBmb3IgKGNvbnN0IGlkIG9mIGFsbE5vZGVJZHMpIHtcbiAgICBpZiAoIXRhcmdldElkcy5oYXMoaWQpKSByZXR1cm4gaWQ7XG4gIH1cbiAgcmV0dXJuIG5vZGVzLmxlbmd0aCA+IDAgPyBub2Rlc1swXS5pZCA6IG51bGw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRMYXlvdXRlZEVsZW1lbnRzKFxuICBub2RlczogTm9kZVtdLFxuICBlZGdlczogRWRnZVtdLFxuICBkaXJlY3Rpb246ICdUQicgfCAnTFInID0gJ1RCJ1xuKSB7XG4gIC8vINeR16DXmdeZ16og16LXpSDXlNeZ16jXqNeb15k6INec15vXnCBub2RlINeg16nXnteV16ggY2hpbGRyZW5cbiAgY29uc3Qgbm9kZU1hcDogUmVjb3JkPHN0cmluZywgTm9kZT4gPSBPYmplY3QuZnJvbUVudHJpZXMobm9kZXMubWFwKG4gPT4gW24uaWQsIG5dKSk7XG4gIGNvbnN0IGNoaWxkcmVuTWFwOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmdbXT4gPSB7fTtcbiAgbm9kZXMuZm9yRWFjaChuID0+IHsgY2hpbGRyZW5NYXBbbi5pZF0gPSBbXTsgfSk7XG4gIGVkZ2VzLmZvckVhY2goZSA9PiB7XG4gICAgaWYgKGNoaWxkcmVuTWFwW2Uuc291cmNlXSkgY2hpbGRyZW5NYXBbZS5zb3VyY2VdLnB1c2goZS50YXJnZXQpO1xuICB9KTtcblxuICAvLyDXl9eZ16nXldeRIGxldmVsICjXoteV157Xpykg15zXm9ecIG5vZGVcbiAgY29uc3QgbGV2ZWxzOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+ID0ge307XG4gIGNvbnN0IHJvb3RJZCA9IGdldFJvb3ROb2RlSWQobm9kZXMsIGVkZ2VzKTtcbiAgaWYgKCFyb290SWQpIHJldHVybiB7IG5vZGVzLCBlZGdlcyB9O1xuICBmdW5jdGlvbiBhc3NpZ25MZXZlbHMobm9kZUlkOiBzdHJpbmcsIGxldmVsOiBudW1iZXIpIHtcbiAgICBpZiAobGV2ZWxzW25vZGVJZF0gIT09IHVuZGVmaW5lZCAmJiBsZXZlbHNbbm9kZUlkXSA8PSBsZXZlbCkgcmV0dXJuO1xuICAgIGxldmVsc1tub2RlSWRdID0gbGV2ZWw7XG4gICAgZm9yIChjb25zdCBjaGlsZElkIG9mIGNoaWxkcmVuTWFwW25vZGVJZF0pIHtcbiAgICAgIGFzc2lnbkxldmVscyhjaGlsZElkLCBsZXZlbCArIDEpO1xuICAgIH1cbiAgfVxuICBhc3NpZ25MZXZlbHMocm9vdElkLCAwKTtcblxuICAvLyDXp9eZ15HXldelIG5vZGVzINec16TXmSBsZXZlbFxuICBjb25zdCBsZXZlbHNBcnI6IHN0cmluZ1tdW10gPSBbXTtcbiAgT2JqZWN0LmVudHJpZXMobGV2ZWxzKS5mb3JFYWNoKChbaWQsIGx2bF0pID0+IHtcbiAgICBpZiAoIWxldmVsc0FycltsdmxdKSBsZXZlbHNBcnJbbHZsXSA9IFtdO1xuICAgIGxldmVsc0FycltsdmxdLnB1c2goaWQpO1xuICB9KTtcblxuICAvLyDXl9eZ16nXldeRIFgvWSDXnNeb15wgbm9kZTog15vXnCDXqNee15Qg15HXqdeV16jXlCwg15vXnCBzaWJsaW5ncyDXkdeo15nXldeV15cg16nXldeV15RcbiAgY29uc3QgcG9zaXRpb25zOiBSZWNvcmQ8c3RyaW5nLCB7IHg6IG51bWJlcjsgeTogbnVtYmVyIH0+ID0ge307XG4gIGZvciAobGV0IGx2bCA9IDA7IGx2bCA8IGxldmVsc0Fyci5sZW5ndGg7IGx2bCsrKSB7XG4gICAgY29uc3QgaWRzID0gbGV2ZWxzQXJyW2x2bF07XG4gICAgY29uc3QgdG90YWxXaWR0aCA9IChpZHMubGVuZ3RoIC0gMSkgKiAobm9kZVdpZHRoICsgbm9kZVNwYWNpbmdYKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgeCA9IC10b3RhbFdpZHRoIC8gMiArIGkgKiAobm9kZVdpZHRoICsgbm9kZVNwYWNpbmdYKTtcbiAgICAgIGNvbnN0IHkgPSBsdmwgKiAobm9kZUhlaWdodCArIG5vZGVTcGFjaW5nWSk7XG4gICAgICBwb3NpdGlvbnNbaWRzW2ldXSA9IHsgeCwgeSB9O1xuICAgIH1cbiAgfVxuXG4gIC8vINei15PXm9eV158gbm9kZXMg16LXnSDXnteZ16fXldedXG4gIGNvbnN0IGxheW91dGVkTm9kZXMgPSBub2Rlcy5tYXAoKG5vZGUpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4ubm9kZSxcbiAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgIHg6IHBvc2l0aW9uc1tub2RlLmlkXS54LFxuICAgICAgICB5OiBwb3NpdGlvbnNbbm9kZS5pZF0ueSxcbiAgICAgIH0sXG4gICAgICB0YXJnZXRQb3NpdGlvbjogZGlyZWN0aW9uID09PSAnTFInID8gJ2xlZnQnIDogJ3RvcCcsXG4gICAgICBzb3VyY2VQb3NpdGlvbjogZGlyZWN0aW9uID09PSAnTFInID8gJ3JpZ2h0JyA6ICdib3R0b20nLFxuICAgICAgZGF0YToge1xuICAgICAgICAuLi5ub2RlLmRhdGEsXG4gICAgICB9LFxuICAgIH07XG4gIH0pO1xuXG4gIHJldHVybiB7IG5vZGVzOiBsYXlvdXRlZE5vZGVzLCBlZGdlcyB9O1xufSAiXSwibmFtZXMiOlsibm9kZVdpZHRoIiwibm9kZUhlaWdodCIsIm5vZGVTcGFjaW5nWCIsIm5vZGVTcGFjaW5nWSIsImdldFJvb3ROb2RlSWQiLCJub2RlcyIsImVkZ2VzIiwiYWxsTm9kZUlkcyIsIlNldCIsIm1hcCIsIm4iLCJpZCIsInRhcmdldElkcyIsImUiLCJ0YXJnZXQiLCJoYXMiLCJsZW5ndGgiLCJnZXRMYXlvdXRlZEVsZW1lbnRzIiwiZGlyZWN0aW9uIiwibm9kZU1hcCIsIk9iamVjdCIsImZyb21FbnRyaWVzIiwiY2hpbGRyZW5NYXAiLCJmb3JFYWNoIiwic291cmNlIiwicHVzaCIsImxldmVscyIsInJvb3RJZCIsImFzc2lnbkxldmVscyIsIm5vZGVJZCIsImxldmVsIiwidW5kZWZpbmVkIiwiY2hpbGRJZCIsImxldmVsc0FyciIsImVudHJpZXMiLCJsdmwiLCJwb3NpdGlvbnMiLCJpZHMiLCJ0b3RhbFdpZHRoIiwiaSIsIngiLCJ5IiwibGF5b3V0ZWROb2RlcyIsIm5vZGUiLCJwb3NpdGlvbiIsInRhcmdldFBvc2l0aW9uIiwic291cmNlUG9zaXRpb24iLCJkYXRhIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/utils/autoLayout.ts\n"));

/***/ })

});